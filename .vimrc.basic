" /* vim: set fdm=marker: */

set nocompatible

if !exists('g:tinyvim')
  let g:tinyvim = 1
endif

colo desert

source $HOME/.vimrc.neobundle

" ### set variables ### {{{
syntax enable
set showmatch
set matchtime=0
set ambiwidth=double
set mouse=
set history=1000
set title
set titlestring=%F%(\ %M%)%(\ (%{getcwd()})%)%(\ %a%)
set completeopt=menuone,preview
set lazyredraw
set expandtab
set ts=2 sw=2
set incsearch
set ignorecase
set smartcase
set autoindent
set nowrap
set nobackup
set hidden
set noswapfile
set backspace=2
set visualbell
set number
set wildmode=list:longest,full
set listchars=tab:\|\ 
set list
set scrolloff=0
set laststatus=2
set cmdheight=1
set showcmd
"set linespace=0
set report=0
let &statusline = "%m%r%y%h%w%{'['.(&fenc!=''?&fenc:&enc).':'.&ff.']'}%< %=%F"

" http://vim-users.jp/2010/07/hack162/
if has('persistent_undo')
  set undodir=~/.vimundo
  set undofile
endif

" }}}

" ### key mapping ### {{{
let mapleader = ","
map <Space> [Space]
noremap [Space] <Nop>
nnoremap j gj
nnoremap k gk
inoremap <S-Insert> <C-r><C-o>+<C-[>
nnoremap <silent> <C-Up> :<C-u>resize +1<CR>
nnoremap <silent> <C-Down> :<C-u>resize -1<CR>
nnoremap <silent> <C-Right> :<C-u>vertical resize +1<CR>
nnoremap <silent> <C-Left> :<C-u>vertical resize -1<CR>
nnoremap <silent> gf <C-w>f
nnoremap <silent> gF <C-w>F
cnoremap <C-g> <C-r>=expand('%:p:h')<CR>/
cnoremap <C-a> <Home>
cnoremap <C-e> <End>
cnoremap <C-f> <Right>
cnoremap <C-b> <Left>

" Undoable <C-w> and <C-u>.
" http://whileimautomaton.net/2007/10/21095500
inoremap <C-w>  <C-g>u<C-w>
inoremap <C-u>  <C-g>u<C-u>

" operator-user.vimに登録
call operator#user#define('ginger', 'g:ginger_user_op')
vmap T <Plug>(operator-ginger)
" }}}

" ### functions ### {{{

" -- s:operator_user_text() {{{
function! s:operator_user_text(motion_wiseness)
  " https://github.com/tyru/operator-html-escape.vim/blob/master/autoload/operator/html_escape.vim
  try
    " For saving &selection. See :help :map-operator
    let sel_save = &l:selection
    let &l:selection = "inclusive"
    " Save @@.
    let reg_save     = getreg('z', 1)
    let regtype_save = getregtype('z')

    if a:motion_wiseness == 'char'
        let ex = '`[v`]"zy'
    elseif a:motion_wiseness == 'line'
        let ex = '`[V`]"zy'
    elseif a:motion_wiseness == 'block'
        let ex = '`[' . "\<C-v>" . '`]"zy'
    else
        " silent execute 'normal! `<' . a:motion_wiseness . '`>'
        echoerr 'internal error, sorry: this block never be reached'
    endif
    execute 'silent normal!' ex
    return @z
  finally
    let &l:selection = sel_save
    call setreg('z', reg_save, regtype_save)
  endtry
endfunction
" }}}

" -- g:ginger() {{{
" based on https://gist.github.com/mattn/5457352
function! g:ginger(text)
  let s:endpoint = 'http://services.gingersoftware.com/Ginger/correct/json/GingerTheText'
  let s:apikey = '6ae0c3a0-afdc-4532-a810-82ded0054236'
  let res = webapi#json#decode(webapi#http#get(s:endpoint, {
        \ 'lang': 'US',
        \ 'clientVersion': '2.0',
        \ 'apiKey': s:apikey,
        \ 'text': a:text}).content)
  let i = 0
  let correct = ''
  echon "Mistake: "
  for rs in res['LightGingerTheTextResult']
    let [from, to] = [rs['From'], rs['To']]
    if i < from
      echon a:text[i : from-1]
      let correct .= a:text[i : from-1]
    endif
    if len(rs['Suggestions']) > 0 && has_key(rs['Suggestions'][0], 'Text')
      echohl WarningMsg
      echon a:text[from : to]
      echohl None
      let correct .= rs['Suggestions'][0]['Text']
    else
      echon a:text[from : to]
      let correct .= a:text[from : to]
    endif
    let i = to + 1
  endfor
  if i < len(a:text)
    echon a:text[i :]
    let correct .= a:text[i :]
  endif
  echon "\nCorrect: ".correct
  " this is
  " Edit memcached
endfunction

function! g:ginger_user_op(motion_wise)
  let text = s:operator_user_text(a:motion_wise)
  call g:ginger(text)
endfunction
" }}}

" }}}

" ### misc ### {{{

set fileencodings=ucs-bom,utf-8,iso-2022-jp-3,iso-2022-jp,euc-jisx0213,euc-jp,sjis,cp932,utf-8

" http://blog.blueblack.net/item_393
augroup InsModeAu
  autocmd!
  autocmd InsertEnter,CmdwinEnter * set noimdisable
  autocmd InsertLeave,CmdwinLeave * set imdisable
augroup END

" http://d.hatena.ne.jp/spiritloose/20060519/1147970872
function s:AddExecmod()
  let line = getline(1)
  if strpart(line, 0, 2) == "#!"
    call system("chmod +x ". expand("%"))
  endif
endfunction
augroup executable
  autocmd BufWritePost * :call s:AddExecmod()
augroup END

" }}}
